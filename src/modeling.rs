use std::collections::HashMap;

use fraction::Decimal;
use serde::{Deserialize, Serialize};

use crate::size::Size;

/// The dimensionality of a material (1D or 2D)
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
pub enum Dimension {
    #[default]
    OneD,
    TwoD,
}

/// A type of material
///
/// Examples:
/// - Pine 2x4
/// - 3/4 inch birch plywood
/// - Green acrylic yarn
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
pub struct Material {
    pub name: String,

    /// Whether the material is 1D or 2D
    pub dimension: Dimension,
}

/// An available supply of a material
///
/// Has a name, length, an optional unit price, and an optional max quantity
///
/// Examples:
/// - Lengths of 8ft available for purchase at $3.50 each, no limit
/// - Lengths of 3ft available on hand (free), limit 5
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Supply {
    pub name: String,
    pub length: Size,

    /// Zero indicates that the material is on-hand (free)
    pub price: Decimal,

    /// -1 indicates that the supply is unlimited
    pub max_quantity: i64,
}

/// A desired part to obtain from a material
///
/// Has a name, length, and quantity
///
/// Examples:
/// - Need ten 8ft lengths
/// - Need two 3ft lengths
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Part {
    pub name: String,
    pub length: Size,

    /// i64 used for consistency with `Supply`, where -1 is used to indicate unlimited
    pub quantity: i64,
}

/// A list of cuts to perform on an item
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CutList {
    /// The index of the supply to pull from (relative to the material's `Supplies` vec)
    pub supply_index: usize,

    /// The part indices that will be cut from the object (relative to the material's `Parts` vec)
    pub part_indices: Vec<usize>,

    /// The number of times this cut list should be performed
    pub quantity: usize,
}

/// A problem definition for a single material
#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct SubProblem {
    /// Available supplies
    pub supplies: Vec<Supply>,

    /// Requested parts
    pub parts: Vec<Part>,

    /// Width of the blade
    ///
    /// Up to this width is removed when making a cut. We don't need the whole blade width available
    /// to make the cut; we can straddle the edge, or the remaining piece might be exactly what we
    /// need.
    pub blade_width: Size,
}

/// A solution for a single material
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubSolution {
    /// Available supplies
    ///
    /// Needed to interpret `cut_lists`, should be moved from `SubProblem`
    pub supplies: Vec<Supply>,

    /// Requested parts
    ///
    /// Needed to interpret `cut_lists`, should be moved from `SubProblem`
    pub parts: Vec<Part>,

    /// Cut lists generated by the solver
    ///
    /// Indices within `CutList` refer to `supplies` and `parts`
    pub cut_lists: Vec<CutList>,
}

pub type Problem = HashMap<Material, SubProblem>;

pub type Solution = HashMap<Material, SubSolution>;
